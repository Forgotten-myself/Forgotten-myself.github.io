<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>2019~2020学年度上OI总结 | Welcome</title>
  <meta name="keywords" content=" 总结 , 哈希 , Trie树 , 树状数组 , 分治 , 二分 , 三分 , 背包 , 树形DP , 区间DP ">
  <meta name="description" content="2019~2020学年度上OI总结 | Welcome">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="既然搬运了$GSS$的题目，那当然还是要写一下题解的啦(树剖部分最好会搬运过来，最坏可能并不会搬运)    GSS1 题目传送门: $OJ      $$luogu$      题意:给出了序列以及$m$组询问，求每组询问区间内的最大子段和.   首先，$GSS$全是数据结构题，因此我们不会去用之前$O(n)$的方法查询，因为这样在最坏情况下时间会退化为$O(nm)$   否决了$O(nm)$的做">
<meta property="og:type" content="article">
<meta property="og:title" content="GSS系列题解">
<meta property="og:url" content="http://forgotten-myself.github.io/2020/02/10/GSS%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/index.html">
<meta property="og:site_name" content="Welcome">
<meta property="og:description" content="既然搬运了$GSS$的题目，那当然还是要写一下题解的啦(树剖部分最好会搬运过来，最坏可能并不会搬运)    GSS1 题目传送门: $OJ      $$luogu$      题意:给出了序列以及$m$组询问，求每组询问区间内的最大子段和.   首先，$GSS$全是数据结构题，因此我们不会去用之前$O(n)$的方法查询，因为这样在最坏情况下时间会退化为$O(nm)$   否决了$O(nm)$的做">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2020/01/01/HX7ownv6y1JhcsE.png">
<meta property="og:image" content="https://i.loli.net/2020/01/01/V8BRYADUfbGdXi2.png">
<meta property="og:image" content="https://i.loli.net/2020/01/01/FpwVjokZcQbudmB.png">
<meta property="og:image" content="https://i.loli.net/2019/12/30/LK9vYFUAJgVH6MO.jpg">
<meta property="article:published_time" content="2020-02-10T14:08:00.000Z">
<meta property="article:modified_time" content="2020-02-11T01:07:52.526Z">
<meta property="article:author" content="Forgotten-myself">
<meta property="article:tag" content="线段树">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/01/01/HX7ownv6y1JhcsE.png">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.0.1" rel="stylesheet">

<link href="/css/hl_theme/sublime.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1.0.1" ></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.0.1" ></script>

<meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="\assets\css\APlayer.min.css" class="aplayer-style-marker">
<script src="\assets\js\APlayer.min.js" class="aplayer-script-marker"></script>
</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value="">
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>Forgotten-myself</span>
</div>

<div class="icon">
    
        
        <a title="github" href="https://github.com/Forgotten-myself" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
        <a title="zhihu" href="https://www.zhihu.com/people/qwqzi-dong-ji" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-zhihu"></use>
                </svg>
            
        </a>
        
    
        
        <a title="email" href="mailto:1275881998@qq.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=1275881998&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"></use>
                </svg>
            
        </a>
        
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(3)</small></div></li>
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="about  hasFriend  site_url"  href="/about">关于</a><a style="width: 50%"  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="3">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode === 13){return false;}">
        <input id="local-search-input" class="search" type="text" placeholder="Search..." />
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a class="color3">总结</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">哈希</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">Trie树</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">树状数组</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">分治</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">二分</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">三分</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">背包</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">树形DP</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">区间DP</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">线段树</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <nav id="title-list-nav">
        
        <a  class=""
           href="/2020/01/30/2019~2020%E5%AD%A6%E5%B9%B4%E5%BA%A6%E4%B8%8AOI%E6%80%BB%E7%BB%93/"
           data-tag="总结,哈希,Trie树,树状数组,分治,二分,三分,背包,树形DP,区间DP"
           data-author="CLJ" >
            <span class="post-title" title="2019~2020学年度上OI总结">2019~2020学年度上OI总结</span>
            <span class="post-date" title="2020-01-30 21:45:00">2020/01/30</span>
        </a>
        
        <a  class=""
           href="/2020/01/30/CSP-J%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"
           data-tag="总结"
           data-author="CLJ" >
            <span class="post-title" title="CSP-J赛后总结">CSP-J赛后总结</span>
            <span class="post-date" title="2020-01-30 21:44:00">2020/01/30</span>
        </a>
        
        <a  class=""
           href="/2020/02/10/GSS%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3/"
           data-tag="线段树"
           data-author="CLJ" >
            <span class="post-title" title="GSS系列题解">GSS系列题解</span>
            <span class="post-date" title="2020-02-10 22:08:00">2020/02/10</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-2019~2020学年度上OI总结" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">2019~2020学年度上OI总结</h1>
    
    <div class="article-meta">
        
        
        <span class="author"><a>CLJ</a></span>
        
        
        
        <span class="tag">
            
            <a class="color3">总结</a>
            
            <a class="color3">哈希</a>
            
            <a class="color1">Trie树</a>
            
            <a class="color5">树状数组</a>
            
            <a class="color3">分治</a>
            
            <a class="color3">二分</a>
            
            <a class="color3">三分</a>
            
            <a class="color3">背包</a>
            
            <a class="color5">树形DP</a>
            
            <a class="color5">区间DP</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title='更新时间: 2020-02-11 09:07:19'>2020-01-30 21:45</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文同步发表于<a href="https://www.luogu.com.cn/blog/1-2-1/2019-2020-sum-up" target="_blank" rel="noopener">$My luogu Blog$</a></p>
<hr>
<p>从$CSP-J$后,差不多又有半年了,然后我们又要搞总结了~($≧▽≦)/~$</p>

        <div id="aplayer-HkspLmHX" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-HkspLmHX"),
            narrow: false,
            autoplay: true,
            showlrc: false,
            music: {
              title: "Luv letter",
              author: "Dj Okawari",
              url: "https://sz-btfs.ftn.qq.com/ftn_handler/85785e073afab799e971fa4e9a0cc0fbda119d9c8d5799baa97264083cb60ced9608c99d9bbd1c47060fb2ccea7a7caf055ca021212799ce1998b81d0021ab81/?fname=DJ%20OKAWARI%20-%20Luv%20Letter%20(%E6%83%85%E4%B9%A6).mp3&k=623032661887369d3b5a3e2a1166534d0753575f060352501804505e014b555407521f5e5350504f05525153545f075507540154374461267f107d2d763120307c101f467b131742795546125214414af2d9f88f1e480c1206300f&code=502f7fab&fr=00&&txf_fid=387cc2d93879b8a2e2097e1ef1e30bb60a7a15be&xffz=11017937",
              pic: "https://sm.ms/delete/dUYjRIqabgxLychK61VFu3CJ5v",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>
<a id="more"></a>
<hr>
<script type="math/tex; mode=display">\texttt{一.字符串Hash}</script><p>$1.$字符串$hash$<br>$       $简单来说,$Hash≈$把字符串转成$ULL.$<br>$       Q:$为什么要用$ULL?$<br>$       A:$利用$ULL$有自然溢出的特性，可以防止负数进而防止数组下标为负</p>
<p>$       $利用类似于<strong>进制</strong>的思想，我们就可以把一个字符串改造成$ULL$<br><img src="https://i.loli.net/2020/01/10/hvKrJDfYo6AZycb.png" alt="cf2951ecbe045cf0949ea278e2c5437e_2_0_photo.png"><br>而利用这个位值的原则，我们可以轻松地求出一个字符串中任意一个子串的值. </p>
<p>$       $设:$p_i$表示在$base$进制下第$i$位的权值(事实上这可以用$base^{i-1}$轻松求得,但空间换时间大部分情况下是划算的),$h_i$表示$s_1-s_j$的子串$hash$值  </p>
<p>$       $所以可得:$s_l-s_r$的子串$hash$值为:  </p>
<script type="math/tex; mode=display">\texttt{h[r]-h[l-1]*sum[r-l+1]}</script><p><del>其实感觉跟前缀和蛮像的</del>  </p>
<p>这个原理很好证明，如果想不明白的话可以用十进制举例  </p>
<p><del>好像就没了?</del>  </p>
<p>$2.$最小(大)表示法<br>$       $尽管$LF$没讲，但个人认为这还是很好理解的.<br>$       $以<a href="http://222.180.160.110:1024/problem/5990" target="_blank" rel="noopener">$P5990$</a>为例,它要求一个字符串从顺时针，逆时针的顺序看过去的串是否有过，这其实相当于把这个字符串改成$12$个子串,我们求出这$12$个子串的$hash$值后取$min/max$即可表示与这个字符串等价的所有其他字符串.  </p>
<p>以样例为例:</p>
<pre><code>1 2 3 4 5 6
</code></pre><p>它可以被改造为: </p>
<pre><code>1 2 3 4 5 6  
2 3 4 5 6 1
3 4 5 6 1 2
4 5 6 1 2 3
5 6 1 2 3 4
6 1 2 3 4 5

6 5 4 3 2 1  
5 4 3 2 1 6
4 3 2 1 6 5
3 2 1 6 5 4
2 1 6 5 4 3
1 6 5 4 3 2
</code></pre><p>这当中最小的应该是$\text{6 5 4 3 2 1}$这个子串的$hash$值，因此我们直接用$\text{6 5 4 3 2 1}$的值表示这$12$个串的值记录下来即可.  </p>
<hr>
<script type="math/tex; mode=display">\texttt{二.trie树}</script><p>个人认为这是学得仅次于$DP$烂的东西.  </p>
<p>$1.$概述<br>$       Q:$为什么要用字典树而不用字典链表什么的呢?</p>
<blockquote>
<p>A:元素与元素间的关系为继承的一对多关系。</p>
</blockquote>
<p>$       $拿字典树来说，每一个元素都可以有几个子元素，作为它之后的字母；而倘若要比对两个字符串是否相同，只需要比对在这棵字典树上，这两个串最后一个元素的祖先链(即前缀)是否相同，并且对于祖先链来说，并不用逐个比较，只需要记录访问就行  </p>
<p>$2.$怎么建一棵字典树?<br>$       $对于一棵字典树来说,我们用边来存储每一个字符?为什么呢?首先我们来想一想,字典树有没有根节点?  </p>
<p>$       $答案肯定是:”没有”,原因很简单,根节点的个数决定它树的棵树，如果根节点太多的话那这个数据结构没有方便可言.<del>而且它叫字典树而不是字典森林</del>  </p>
<p>$       $那没有根节点，也就没有了用点存储字符的可能性,因此用边是唯一的选择,节点的话，我们留着拿来编号用.  </p>
<script type="math/tex; mode=display">\mathcal{CODE}</script><pre><code class="lang-cpp">int trie[N][26],End[N],tot=1;
void insert(char a[])
{
    int len=strlen(a),p=1;
    for(int i=0;i&lt;len;i++)
    {
        int ch=a[i]-&#39;a&#39;;
        if(trie[p][ch]==0)  trie[p][ch]=(++tot);
        p=trie[p][ch];
    }
    End[p]++;
}
</code></pre>
<p>$3.$查询<br>$        trie[i][ch]$表示$i$节点有$ch$这个字符,其编号为$tot$  </p>
<pre><code class="lang-cpp">bool Search(char a[])
{
    int len=strlen(a),p=1,ans=0;
    for(int i=0;i&lt;len;i++)
    {
        p=trie[p][a[i]-&#39;a&#39;];
        if (p==0) return false;
    }
    return true;
}
</code></pre>
<p>$       $这段代码表示查询前面有没有是它前缀的字符串.  </p>
<p>$       $那我们之前打的$End$标记是干吗的呢?我们把代码改成这个亚子.  </p>
<pre><code class="lang-cpp">int Search(char a[])
{
    int len=strlen(a),p=1,ans=0;
    for(int i=0;i&lt;len;i++)
    {
        p=trie[p][a[i]-&#39;a&#39;];
        if(p==0) return ans;
        ans+=End[p];
    }
    return ans;
}
</code></pre>
<p>$       $这就能查询之前建过的所有链中,有多少单词是当前要查询的单词的<strong>前缀</strong> <del>(好像还是没啥用?)</del>.  </p>
<p>$4.01 Trie$<br>$       01 Trie$树可以干吗?<del>搞异或</del>,求一个数列当中任意两个数异或能得到的最大值<br>$       $由异或的定义可得:   </p>
<script type="math/tex; mode=display">\texttt{0 xor 0=0\ \ \ \ \ 0 xor 1=1\ \ \ \ \ 1 xor 0=1\ \ \ \ \ 1 xor 1=0}</script><p>$       $再根据一个小小的贪心，<strong>最高位如果是$1$的话,下面的低位不管是什么都比不上它的</strong>.<br>$       E.g:(1000)_2&gt;(0111)_2$  </p>
<p>$       $所以剩下的就是，我们把一个数改成$32$位<strong>二进制</strong>数放在$Trie$树上，然后发现与当前位上<strong>不一样</strong>的数就<strong>直接</strong>往那条边走，否则就只能往当前位上和它<strong>相同数字方向</strong>走.  </p>
<p>$       $我能贴个<a href="http://222.180.160.110:1024/problem/5996" target="_blank" rel="noopener">$5996$</a>的<a href="https://www.luogu.com.cn/paste/imgihbdm" target="_blank" rel="noopener">代码</a>就跑吗?  </p>
<hr>
<script type="math/tex; mode=display">\texttt{三、树状数组}</script><p><a href="https://www.luogu.com.cn/blog/1-2-1/BIT-note" target="_blank" rel="noopener">或许我有写过?</a>  </p>
<hr>
<script type="math/tex; mode=display">\texttt{四、二分 and 三分}</script><p>$1.$二分<br>$       $对于一个有单调性的函数.(我们也可以把一个问题的解看做是一个单调函数)我们可以用二分求出它与$x$轴的交点(这个问题的解) </p>
<p>$       $还是举个例子吧<a href="https://www.luogu.com.cn/problem/P1314" target="_blank" rel="noopener">$P1314$</a> <del>(好像这道题也可以三分?)</del><br>$       $对于这题，我们可以发现，选不同的$W$会有不同的差值,而$W$越大，矿石选的越少，$W$越<strong>小</strong>，矿石选的越<strong>多</strong>,自然,随着$W$<strong>增大</strong>,$Y$值<strong>减小</strong><br>$       $所以我们需要做的,就只要<strong>二分</strong>$W$,然后对于每一个求出的$W$进行一次<strong>求解</strong>(要用前缀和优化)找到与目标$Y$<strong>最接近的值</strong>即可.  </p>
<p>$       $再举个例子<a href="https://www.luogu.com.cn/problem/P2619" target="_blank" rel="noopener">$P2619$</a><br>$       $这道题我们可以清楚得看到，在保证最优解的情况下,选择白色边的数量是很难决定的.那不如……?我们<strong>先跑一边最优解</strong>(最小生成树),如果刚好有$need$条边,那么就可以直接输出,那如果不然呢? </p>
<p>$       1.$如果它白边<strong>少</strong>了,那么我们可以让白边的权值$down$(<strong>减掉一个值</strong>),最后答案再$up$(加$need$条边回去)  </p>
<p>$       2.$如果它白边<strong>多</strong>了,那么我们可以让白边的权值$up$(<strong>加上一个值</strong>),最后答案再$down$(减$need$条边回去)  </p>
<p>$       $所以很明显,我们<strong>二分</strong>这个<strong>加/减去的值</strong>$(l-100,r=100)$,最后只要求得白边$\le need$即可更新答案.  </p>
<p>$2.$三分<br>$       $三分最常见的用法就是求一个<strong>区间单峰函数</strong>的<strong>极值</strong>,最常见的单峰函数是什么?当然就是<strong>二次函数</strong>啦~(≧▽≦)/~.<br><img src="https://i.loli.net/2020/01/10/vrkwlBIOKqUWhst.png" alt="8f495fbf7a0ea76deb58e86555428b07_2_0_photo.png">  </p>
<p>$       $对于一个二次函数，我们假设其<strong>定义域</strong>在$[l_i,r_i]$,我们手算的时候,假设这个区间为$[-3,3]$吧.  </p>
<p>$       $那么,我们可以求出这个区间的<strong>三等分点</strong>,对于这个例子来说,我们的三等分点就是$m1_x=l+\frac{r-l}{3}=1,m2_x=r-\frac{r-l}{3}=1$,它们的函数值相等,我们任意下移某一边的点,这里我们下移$l$，变为$[-1,3]$  </p>
<p>$       $继续计算,$m1_x=l+\frac{r-l}{3}=\frac{1}{3},m2_x=r-\frac{r-l}{3}=\frac{5}{3}$,$m1$的函数值小一些，我们把$l$<strong>下移</strong>下去.  </p>
<p>$       $它就会变成$[\frac{5}{3},3]$,以此类推,我们可以把$l$和$r$ 夹在一个范围之内.  </p>
<p>$       $<del>了解了这些过后,我们就会明白</del><a href="https://www.luogu.com.cn/problem/P3382" target="_blank" rel="noopener">$P3382$</a>&amp;<a href="http://222.180.160.110:1024/problem/17" target="_blank" rel="noopener">$17$</a>就是板子题了  </p>
<p>$3.EX$三分  </p>
<blockquote>
<p>题目传送门:<a href="http://222.180.160.110:1024/problem/21" target="_blank" rel="noopener">$OJ$</a>$    $<a href="https://www.luogu.com.cn/problem/P2571" target="_blank" rel="noopener">$Luogu$</a>  </p>
</blockquote>
<p>$      $先声明一下,我到现在都还是<strong>没有过掉</strong>,我不知道为什么它$WA$成$80$分,但我敢相信它的思路一定是正确的.  </p>
<p>$      $我们不难发现,总的时间一定是:  </p>
<script type="math/tex; mode=display">Time=\frac{AE}{V_{AB}}+\frac{EF}{V}+\frac{FD}{V_{CD}}</script><p>$      $首先,我们可以假设<strong>传送带速度大于走路的速度</strong>,并且我们在$AB$段离开的点已经定下来为$E$点<br><img src="https://i.loli.net/2020/01/11/CmugQolaNOb5epT.png" alt="无标题.png"><br>$      $我们假设$A→E→N→D$为最优路径,我们来看以下三种情况(讨论中我们自动忽略$A→E$与$P→D$的时间).  </p>
<script type="math/tex; mode=display">\texttt{No.1 E}→\texttt{M}→\texttt{D}:T=\frac{x}{V}+\frac{a+b}{V_{CD}}</script><script type="math/tex; mode=display">\texttt{No.2 E}→\texttt{N}→\texttt{D}:T=\frac{y}{V}+\frac{b}{V_{CD}}</script><script type="math/tex; mode=display">\texttt{No.3 E}→\texttt{P}→\texttt{D}:T=\frac{z}{V}</script><p>$       $鉴于$x&lt;y&lt;z,$我们设$x=y-p,z=y+q$,所以我们的式子可以表示为:  </p>
<script type="math/tex; mode=display">\texttt{No.1 E}→\texttt{M}→\texttt{D}:T=\frac{y-p}{V}+\frac{a+b}{V_{CD}}</script><script type="math/tex; mode=display">\texttt{No.2 E}→\texttt{N}→\texttt{D}:T=\frac{y}{V}+\frac{b}{V_{CD}}</script><script type="math/tex; mode=display">\texttt{No.3 E}→\texttt{P}→\texttt{D}:T=\frac{y+q}{V}</script><p>$       $将上述三个式子全都减掉相同的$\frac{y}{V}$,原式又会变为  </p>
<script type="math/tex; mode=display">\texttt{No.1 E}→\texttt{M}→\texttt{D}:T=\frac{a+b}{V_{CD}}-\frac{p}{V}</script><script type="math/tex; mode=display">\texttt{No.2 E}→\texttt{N}→\texttt{D}:T=\frac{b}{V_{CD}}</script><script type="math/tex; mode=display">\texttt{No.3 E}→\texttt{P}→\texttt{D}:T=\frac{q}{V}</script><p>$       $一般情况下,$V_{CD}&gt;V$,所以可以得到这是一个<strong>单峰函数</strong>的,当然,如果$V_{CD}&lt;V$,那我们直接<strong>特判</strong>就好啦.  </p>
<p>$       $以此类推,我们也就得到了对于$AB$段的函数单峰性证明  <del>(其实<strong>并没有</strong>,但我真的证不出来了)</del>  </p>
<p>$       $所以这道题的正解就是,先<strong>三分</strong>$AB$上的$E$点,然后用三分出来的$E$点三分$CD$上的$F$点,然后用求得的最优解逼近最正确的$E$点.  </p>
<script type="math/tex; mode=display">\mathcal{CODE(8Opts)}</script><blockquote>
<p>$       $<a href="https://www.luogu.com.cn/paste/8i3r74ab" target="_blank" rel="noopener">码量过大,为防止卡顿故使用云剪贴板</a></p>
</blockquote>
<p>$       $<del>当然这道题也可以用模拟退火,粒子群优化和暴力(拆成$500$个点)乱搞</del>  </p>
<hr>
<script type="math/tex; mode=display">\texttt{四、背包DP}</script><p>$      $<a href="https://www.luogu.com.cn/blog/1-2-1/bag-question" target="_blank" rel="noopener">很明显,我有写过</a>  </p>
<hr>
<script type="math/tex; mode=display">\texttt{五、树形DP}</script><p>$      $<del>我们会树,我们会$DP$,我们会树上$DP$.</del>   </p>
<p>$1.$树的直径<br>$      $对于树的直径，我们普遍有两种做法</p>
<p>$      $一种是贪心两遍 $\text{dfs}$或 $\text{bfs}$,另外一种是树形 $\text{dp}$<br>$   $①.定义<br>$      $给定一棵树，<br>$      $树中每条边都有一个权值，<br>$      $树中两点之间的距离定义为连接两点的路径边权之和。<br>$      $树中最远的两个节点之间的距离被称为树的直径，<br>$      $连接这两点的路径被称为树的最长链<br>$      $简单来说，树的直径就是树上一条最长的链的距离  </p>
<p>$   $②.流程<br>$      $我们以下图为例<br><img src="https://i.loli.net/2020/01/11/NdLv9QktSAXlPqW.png" alt="graph.png">   </p>
<p>$      $我们任意选择一个点$W$,这里我们以$2$为例<br>$      $那么离$2$最远的就是$6$,我们再找一遍离$6$最远的节点:$4$。<br>$      $所以我们的最长链就是两次找到的两个节点所形成的链.<br>$      $至于正确性证明,可以看一下大佬的<a href="https://www.luogu.com.cn/blog/Loveti/problem-tree" target="_blank" rel="noopener">$\texttt{BLOG}$</a>    </p>
<p>$      $而树形$\texttt{DP}$的话,我们可以用下面这种方法.   </p>
<p>$      $令$\texttt{DP1[i]}$表示起点为$i$的最长链,$\texttt{DP2[i]}$表示起点为$i$的(非严格)次长链,那么我们可以得到$ans=\max\{dp1[i],dp2[i]\}(1 \le i \le n)$<br>$      $所以转移方程肯定是这样写的($\text{u}$代表当前节点,$\text{v}$表示$\text{u}$的子节点):  </p>
<pre><code class="lang-cpp">//当中的1全都可以换成w(边权)
if(dp1[u]&lt;=dp1[v]+1)
{
    dp2[u]=dp1[u];//这两个顺序不能变换
    dp1[u]=dp1[v]+1;
}
else if(dp2[u]&lt;=dp1[v]+1) dp2[u]=dp1[v]+1;//else 不能去掉
</code></pre>
<p>$       $这个意思应该很清楚吧,如果我们能更新最长链,那么我们先更新<strong>次长链</strong>为<strong>当前最长链,最长链</strong>为当前新得到的值.<br>$       $如果上面这个不成立,我们再来找一下能不能更新次长链<br>$       $所以很明显,找直径的树形$\text{DP}$是由子节点到根节点的.<br>$       $例题传送门:<a href="http://222.180.160.110:1024/problem/160" target="_blank" rel="noopener">$160$</a><br>$       $乍一看这道题都跟树没有关系,然而事实上,我们可以把可以<strong>互相转化</strong>的数看做是在这两个节点之间<strong>连了一条边</strong>,因此这道题就是求一个树上的最长链,即树的直径.</p>
<p>$       $由于这道题一定是从大数转换为小数,所以我们倒序枚举即可.  </p>
<script type="math/tex; mode=display">\mathcal{CODE}</script><pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;
int sum[50005],d1[50005],d2[50005];
int main() {
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=2;j&lt;=n/i;j++) sum[i*j]+=i;
    }
    for(int i=n;i&gt;=1;i--)
    {
        if(sum[i]&lt;i)
        {
            if(d1[i]+1&gt;d1[sum[i]])
            {
                d2[sum[i]]=d1[sum[i]];
                d1[sum[i]]=d1[i]+1;
            }
            else if(d1[i]+1&gt;d2[sum[i]]) d2[sum[i]]=d1[i]+1;
        }
    }
    int ans=-1;
    for(int i=1;i&lt;=n;i++) ans=max(ans,d1[i]+d2[i]);
    printf(&quot;%d&quot;,ans);
    return 0;
}
</code></pre>
<p>$2.$树的最大独立集<br>$       $这个,怎么说呢?其实就是给定一些限制,然后在满足这些限制的前提下最多/最少能取多少个点.<br>$       $具体我们以找一道<a href="https://www.luogu.com.cn/problem/UVA1220" target="_blank" rel="noopener">例题</a>把.<br>$       $<a href="https://www.luogu.com.cn/blog/1-2-1/solution-uva1220" target="_blank" rel="noopener">解析</a>在这里.  </p>
<p>$3.$树的重心<br>$       $考虑一个点，以它为根的树中，最大的子树节点数最少，我们把这个点称为树的重心<br>$       $举个例子，下图中重心为 $1$ 和 $2$<br><img src="https://i.loli.net/2020/01/11/oJgbeBnIY7c5drk.png" alt="graph.png"><br>$   $①求法<br>$       $求解树的重心的时候，我们通常会采用树形 $\text{dp}$<br>$       $我们用 $s[i]$ 代表以 $i$ 为根的子树节点数<br>$       dp[i]$代表以 $i$ 为根的子树中最大的子树节点个数<br>$       $显然，$dp[u]=\max(dp[u],s[v])$<br>$       $但是我们求重心的时候，是以 $u$ 为根。<br>$       $还是举上图的例子，当我们把$2$号点当成重心时，它就变成了这样<br><img src="https://i.loli.net/2020/01/11/Wl9esZHMf1F3XoS.png" alt="graph _1_.png"><br>$       $<del>这时候 2 号节点的父亲变成了儿子</del><br>$       $所以最后统计 $dp[u]$ 的时候，还要记得统计 $n-s[u]$(即以原来父亲为根的子树的节点数)  </p>
<p>$       $还是搞一个例题吧.<br>$       $题目传送门:<a href="http://222.180.160.110:1024/problem/10795" target="_blank" rel="noopener">$OJ$</a>$   $<a href="https://www.luogu.com.cn/problem/SP9942" target="_blank" rel="noopener">$SP9942$</a><br>$       $<del>我想知道为什么我考场上没有看出来这是重心</del>  </p>
<p>$       $我们求出来以原来每一个点的父亲一坨子树还是儿子一坨子树的节点数多,那么我们就让多的经过这条边即可.  </p>
<script type="math/tex; mode=display">\mathcal{CODE}</script><blockquote>
<p>$       $<a href="https://www.luogu.com.cn/paste/bfc8l6d0" target="_blank" rel="noopener">$Here it is!$</a>  </p>
</blockquote>
<p>$       $树形$DP$先讲三大模板吧,后面再填坑.  </p>
<blockquote>
<p>To Be Continued</p>
</blockquote>
<hr>
<script type="math/tex; mode=display">\texttt{六、区间DP}</script><p>$    1.$模板?<br>$        $区间$\text{DP}$一般有这样的套路.  </p>
<pre><code class="lang-cpp">for(int len=2;len&lt;=n;len++)
{
    for(int i=1;j=len;j&lt;=n;i++,j++)
    {
        for(int k=i;k&lt;j;k++)
        {
            dp[i][j]= (max or min) (dp[i][j],dp[i][k] (+ or *) dp[k+1][j] (+ or *) (视题目而定) )
        }
    }
}
</code></pre>
<p>$    $2.套路<br>$        $ 区间$\text{DP}一般有一个$<br>$        $ 破环为链 $  \Theta(n)$ ,代码简单,不展示了.<br>$        E.g$:<a href="http://222.180.160.110:1024/problem/152" target="_blank" rel="noopener">$1552$</a>$    $<a href="https://www.luogu.com.cn/problem/P1880" target="_blank" rel="noopener">$P1880$</a>  </p>
<p>$    $3.例题  </p>
<blockquote>
<p>$        $<a href="http://222.180.160.110:1024/problem/6119" target="_blank" rel="noopener">$OJ$</a>$   $  <a href="https://www.luogu.com.cn/problem/P4342" target="_blank" rel="noopener">$Luogu$</a>  </p>
</blockquote>
<p>$         $我们记$\text{op[i]}$表示第$\text{i}$条边的操作,设$\text{dp[i][j]}$表示在$i-j$的边序列操作后所能得到的最大值.<br>$         $我们很容易就能发现:  </p>
<script type="math/tex; mode=display">\texttt{dp[i][j]=}\max\texttt{\{(dp[i][k]+dp[k+1][j])\}}\ \ (op[k+1]=='+')</script><script type="math/tex; mode=display">\texttt{dp[i][j]=}\max\texttt{\{(dp[i][k]*dp[k+1][j])\}}\ \ (op[k+1]=='*')</script><p>$         $于是你高高兴兴地交上去,发现只有$80pts$  </p>
<p>$         $为什么呢? <del>这可是IOI诶,即使再水也不至于这样吧.</del> 我们来看一下数据范围  </p>
<blockquote>
<p>$         $顶点数字都在$[-32768,32767]$ </p>
</blockquote>
<p>$         $所以很明显,这里是因为负数$\times$负数很有可能超过当前最大值,所以我们还要维护一个最小值。  </p>
<p>$         $设:$\texttt{DP1[i][j]}$维护最小值,$\texttt{DP2[i][j]}$维护最大值<br>$         $那么我们的状态转移方程就会变成下面这个亚子.  </p>
<script type="math/tex; mode=display">\texttt{if(op[k+1]=='+')}</script><script type="math/tex; mode=display">\texttt{dp1[i][j]=} \min \texttt{\{dp1[i][k]+dp1[k+1][j]\}}</script><script type="math/tex; mode=display">\texttt{dp2[i][j]=} \max \texttt{\{dp2[i][k]+dp2[k+1][j]\}}</script><script type="math/tex; mode=display">\texttt{if(op[k+1]=='*')}</script><script type="math/tex; mode=display">\texttt{dp1[i][j]=} \min \texttt{\{dp1/2[i][k]*dp1/2[k+1][j]\}}</script><script type="math/tex; mode=display">\texttt{dp2[i][j]=} \max \texttt{\{dp2/1[i][k]*dp2/1[k+1][j]\}}</script><p>$        $乘法完整打出来有$8$行,所以我稍微简化了一下,$dp1/2[i][j]$表示它既得取$dp1$,又得取$dp2$.  </p>
<script type="math/tex; mode=display">\mathcal{CODE}</script><blockquote>
<p><a href="https://www.luogu.com.cn/paste/32t17f02" target="_blank" rel="noopener">Here it is!</a></p>
</blockquote>
<hr>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jaytp@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>


<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>2019~2020学年度上OI总结</p>
    
    <p><span class="copy-title">本文作者:</span><a  title="Forgotten-myself">Forgotten-myself</a></p>
    <p><span class="copy-title">发布时间:</span>2020-01-30, 21:45:00</p>
    <p><span class="copy-title">最后更新:</span>2020-02-11, 09:07:19</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2020/01/30/2019~2020%E5%AD%A6%E5%B9%B4%E5%BA%A6%E4%B8%8AOI%E6%80%BB%E7%BB%93/" title="2019~2020学年度上OI总结">http://forgotten-myself.github.io/2020/01/30/2019~2020%E5%AD%A6%E5%B9%B4%E5%BA%A6%E4%B8%8AOI%E6%80%BB%E7%BB%93/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
    </p>
</div>





    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="//cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<input type="hidden" id="MathJax-js"
        value="//cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
</input>
    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2016-2019 Yelog</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" ></a>

    </div>
</div>
<div class="acParent"></div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.0.1" ></script>

<script src="/js/script.js?v=1.0.1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['@CLJ','@LJS','#总结','#哈希','#Trie树','#树状数组','#分治','#二分','#三分','#背包','#树形DP','#区间DP','#线段树',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 492px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("https://cdn.luogu.com.cn/upload/image_hosting/vmq7zc0o.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







</html>
