<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="keywords" content="Forgotten-myself, Welcome"><meta name="description" content=""><title>2019~2020学年度上OI总结</title><link rel="icon" href="/images/icons/favicon-16x16.png?v=1.7.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=1.7.0" type="image/png" sizes="32x32"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=1.7.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontawesome: {"prefix":"fa"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  post_widget: {"end_text":true},
  night_mode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","word_wrap":false},
  reward: false,
  fancybox: false,
  zoom_image: {"enable":true,"mask_color":"rgba(0,0,0,0.6)"},
  gallery_waterfall: undefined,
  lazyload: undefined,
  pjax: undefined,
  external_link: {"icon":{"enable":true,"name":"external-link"}},
  shortcuts: undefined,
  prompt: {"copy_success":"Copy Success","copy_error":"Copy Error","creative_commons":"Creative Commons","copy_button":"Copy"}
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-btn fa fa-bars"></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__a" href="/"><i class="fa fa-home"></i>Home</a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__a" href="/archives/"><i class="fa fa-folder-open"></i>Archives</a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-info"><div class="header-info-inner"><div class="header-info-title">Welcome</div><div class="header-info-subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content"><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-header-title">2019~2020学年度上OI总结</h1><div class="post-header-meta"><span class="post-header-meta-create"><i class="fa fa-calendar-o"></i><span>Posted </span><span>2020-01-30</span></span><span class="post-header-meta-update"><i class="fa fa-calendar-check-o"></i><span>updated </span><span>2020-01-30</span></span></div></header><div class="post-body"><p>本文同步发表于<span class="external-link"><a   href="https://www.luogu.com.cn/blog/1-2-1/2019-2020-sum-up"  target="_blank" rel="noopener">$My luogu Blog$</a><i class="fa fa-external-link"></i></span></p>
<hr>
<p>从$CSP-J$后,差不多又有半年了,然后我们又要搞总结了~($≧▽≦)/~$</p>
<hr>
<script type="math/tex; mode=display">\texttt{一.字符串Hash}</script><p>$1.$字符串$hash$<br>$       $简单来说,$Hash≈$把字符串转成$ULL.$<br>$       Q:$为什么要用$ULL?$<br>$       A:$利用$ULL$有自然溢出的特性，可以防止负数进而防止数组下标为负</p>
<p>$       $利用类似于<strong>进制</strong>的思想，我们就可以把一个字符串改造成$ULL$<br><img src="https://i.loli.net/2020/01/10/hvKrJDfYo6AZycb.png" alt="cf2951ecbe045cf0949ea278e2c5437e_2_0_photo.png"><br>而利用这个位值的原则，我们可以轻松地求出一个字符串中任意一个子串的值. </p>
<p>$       $设:$p_i$表示在$base$进制下第$i$位的权值(事实上这可以用$base^{i-1}$轻松求得,但空间换时间大部分情况下是划算的),$h_i$表示$s_1-s_j$的子串$hash$值  </p>
<p>$       $所以可得:$s_l-s_r$的子串$hash$值为:  </p>
<script type="math/tex; mode=display">\texttt{h[r]-h[l-1]*sum[r-l+1]}</script><p><del>其实感觉跟前缀和蛮像的</del>  </p>
<p>这个原理很好证明，如果想不明白的话可以用十进制举例  </p>
<p><del>好像就没了?</del>  </p>
<p>$2.$最小(大)表示法<br>$       $尽管$LF$没讲，但个人认为这还是很好理解的.<br>$       $以<span class="external-link"><a   href="http://222.180.160.110:1024/problem/5990"  target="_blank" rel="noopener">$P5990$</a><i class="fa fa-external-link"></i></span>为例,它要求一个字符串从顺时针，逆时针的顺序看过去的串是否有过，这其实相当于把这个字符串改成$12$个子串,我们求出这$12$个子串的$hash$值后取$min/max$即可表示与这个字符串等价的所有其他字符串.  </p>
<p>以样例为例:<br><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></div></figure><br>它可以被改造为:<br><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6  </span><br><span class="line">2 3 4 5 6 1</span><br><span class="line">3 4 5 6 1 2</span><br><span class="line">4 5 6 1 2 3</span><br><span class="line">5 6 1 2 3 4</span><br><span class="line">6 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">6 5 4 3 2 1  </span><br><span class="line">5 4 3 2 1 6</span><br><span class="line">4 3 2 1 6 5</span><br><span class="line">3 2 1 6 5 4</span><br><span class="line">2 1 6 5 4 3</span><br><span class="line">1 6 5 4 3 2</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">这当中最小的应该是$\text&#123;6 5 4 3 2 1&#125;$这个子串的$hash$值，因此我们直接用$\text&#123;6 5 4 3 2 1&#125;$的值表示这$12$个串的值记录下来即可.  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">$$\texttt&#123;二.trie树&#125;$$  </span><br><span class="line">个人认为这是学得仅次于$DP$烂的东西.  </span><br><span class="line"></span><br><span class="line">$1.$概述  </span><br><span class="line">$\ \ \ \ \ \ \ Q:$为什么要用字典树而不用字典链表什么的呢?</span><br><span class="line">&gt;A:元素与元素间的关系为继承的一对多关系。</span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ \ $拿字典树来说，每一个元素都可以有几个子元素，作为它之后的字母；而倘若要比对两个字符串是否相同，只需要比对在这棵字典树上，这两个串最后一个元素的祖先链(即前缀)是否相同，并且对于祖先链来说，并不用逐个比较，只需要记录访问就行  </span><br><span class="line"></span><br><span class="line">$2.$怎么建一棵字典树?  </span><br><span class="line">$\ \ \ \ \ \ \ $对于一棵字典树来说,我们用边来存储每一个字符?为什么呢?首先我们来想一想,字典树有没有根节点?  </span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ \ $答案肯定是:&quot;没有&quot;,原因很简单,根节点的个数决定它树的棵树，如果根节点太多的话那这个数据结构没有方便可言.~~而且它叫字典树而不是字典森林~~  </span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ \ $那没有根节点，也就没有了用点存储字符的可能性,因此用边是唯一的选择,节点的话，我们留着拿来编号用.  </span><br><span class="line"></span><br><span class="line">$$\mathcal&#123;CODE&#125;$$  </span><br><span class="line">&#96;&#96;&#96;cpp</span><br><span class="line">int trie[N][26],End[N],tot&#x3D;1;</span><br><span class="line">void insert(char a[])</span><br><span class="line">&#123;</span><br><span class="line">    int len&#x3D;strlen(a),p&#x3D;1;</span><br><span class="line">    for(int i&#x3D;0;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int ch&#x3D;a[i]-&#39;a&#39;;</span><br><span class="line">        if(trie[p][ch]&#x3D;&#x3D;0)  trie[p][ch]&#x3D;(++tot);</span><br><span class="line">        p&#x3D;trie[p][ch];</span><br><span class="line">    &#125;</span><br><span class="line">    End[p]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><br>$3.$查询<br>$        trie[i][ch]$表示$i$节点有$ch$这个字符,其编号为$tot$<br><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Search</span><span class="params">(<span class="keyword">char</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(a),p=<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p=trie[p][a[i]-<span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">if</span> (p==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">$\ \ \ \ \ \ \ $这段代码表示查询前面有没有是它前缀的字符串.  </span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ \ $那我们之前打的$End$标记是干吗的呢?我们把代码改成这个亚子.  </span><br><span class="line">```cpp</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">char</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(a),p=<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p=trie[p][a[i]-<span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        ans+=End[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">$\ \ \ \ \ \ \ $这就能查询之前建过的所有链中,有多少单词是当前要查询的单词的**前缀** ~~(好像还是没啥用?)~~.  </span><br><span class="line"></span><br><span class="line">$<span class="number">4.01</span>\ Trie$  </span><br><span class="line">$\ \ \ \ \ \ \ <span class="number">01</span>\ Trie$树可以干吗?~~搞异或~~,求一个数列当中任意两个数异或能得到的最大值  </span><br><span class="line">$\ \ \ \ \ \ \ $由异或的定义可得:   </span><br><span class="line">$$\texttt&#123;<span class="number">0</span> <span class="keyword">xor</span> <span class="number">0</span>=<span class="number">0</span>\ \ \ \ \ <span class="number">0</span> <span class="keyword">xor</span> <span class="number">1</span>=<span class="number">1</span>\ \ \ \ \ <span class="number">1</span> <span class="keyword">xor</span> <span class="number">0</span>=<span class="number">1</span>\ \ \ \ \ <span class="number">1</span> <span class="keyword">xor</span> <span class="number">1</span>=<span class="number">0</span>&#125;$$  </span><br><span class="line">$\ \ \ \ \ \ \ $再根据一个小小的贪心，**最高位如果是$<span class="number">1</span>$的话,下面的低位不管是什么都比不上它的**.  </span><br><span class="line">$\ \ \ \ \ \ \ E.g:(<span class="number">1000</span>)_2&gt;(<span class="number">0111</span>)_2$  </span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ \ $所以剩下的就是，我们把一个数改成$<span class="number">32</span>$位**二进制**数放在$Trie$树上，然后发现与当前位上**不一样**的数就**直接**往那条边走，否则就只能往当前位上和它**相同数字方向**走.  </span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ \ $我能贴个[$<span class="number">5996</span>$](http:<span class="comment">//222.180.160.110:1024/problem/5996)的[代码](https://www.luogu.com.cn/paste/imgihbdm)就跑吗?  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">$$\texttt&#123;三、树状数组&#125;$$  </span><br><span class="line">[或许我有写过?](https:<span class="comment">//www.luogu.com.cn/blog/1-2-1/BIT-note)  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">$$\texttt&#123;四、二分 <span class="keyword">and</span> 三分&#125;$$</span><br><span class="line"></span><br><span class="line">$<span class="number">1.</span>$二分  </span><br><span class="line">$\ \ \ \ \ \ \ $对于一个有单调性的函数.(我们也可以把一个问题的解看做是一个单调函数)我们可以用二分求出它与$x$轴的交点(这个问题的解) </span><br><span class="line"> </span><br><span class="line">$\ \ \ \ \ \ \ $还是举个例子吧[$P1314$](https:<span class="comment">//www.luogu.com.cn/problem/P1314) ~~(好像这道题也可以三分?)~~   </span></span><br><span class="line">$\ \ \ \ \ \ \ $对于这题，我们可以发现，选不同的$W$会有不同的差值,而$W$越大，矿石选的越少，$W$越**小**，矿石选的越**多**,自然,随着$W$**增大**,$Y$值**减小**  </span><br><span class="line">$\ \ \ \ \ \ \ $所以我们需要做的,就只要**二分**$W$,然后对于每一个求出的$W$进行一次**求解**(要用前缀和优化)找到与目标$Y$**最接近的值**即可.  </span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ \ $再举个例子[$P2619$](https:<span class="comment">//www.luogu.com.cn/problem/P2619)  </span></span><br><span class="line">$\ \ \ \ \ \ \ $这道题我们可以清楚得看到，在保证最优解的情况下,选择白色边的数量是很难决定的.那不如……?我们**先跑一边最优解**(最小生成树),如果刚好有$need$条边,那么就可以直接输出,那如果不然呢? </span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ \ <span class="number">1.</span>$如果它白边**少**了,那么我们可以让白边的权值$down$(**减掉一个值**),最后答案再$up$(加$need$条边回去)  </span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ \ <span class="number">2.</span>$如果它白边**多**了,那么我们可以让白边的权值$up$(**加上一个值**),最后答案再$down$(减$need$条边回去)  </span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ \ $所以很明显,我们**二分**这个**加/减去的值**$(l<span class="number">-100</span>,r=<span class="number">100</span>)$,最后只要求得白边$\le need$即可更新答案.  </span><br><span class="line"></span><br><span class="line">$<span class="number">2.</span>$三分  </span><br><span class="line">$\ \ \ \ \ \ \ $三分最常见的用法就是求一个**区间单峰函数**的**极值**,最常见的单峰函数是什么?当然就是**二次函数**啦~\(≧▽≦)/~.  </span><br><span class="line">![<span class="number">8f</span>495fbf7a0ea76deb58e86555428b07_2_0_photo.png](https:<span class="comment">//i.loli.net/2020/01/10/vrkwlBIOKqUWhst.png)  </span></span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ \ $对于一个二次函数，我们假设其**定义域**在$[l_i,r_i]$,我们手算的时候,假设这个区间为$[<span class="number">-3</span>,<span class="number">3</span>]$吧.  </span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ \ $那么,我们可以求出这个区间的**三等分点**,对于这个例子来说,我们的三等分点就是$m1_x=l+\frac&#123;r-l&#125;&#123;<span class="number">3</span>&#125;=<span class="number">1</span>,m2_x=r-\frac&#123;r-l&#125;&#123;<span class="number">3</span>&#125;=<span class="number">1</span>$,它们的函数值相等,我们任意下移某一边的点,这里我们下移$l$，变为$[<span class="number">-1</span>,<span class="number">3</span>]$  </span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ \ $继续计算,$m1_x=l+\frac&#123;r-l&#125;&#123;<span class="number">3</span>&#125;=\frac&#123;<span class="number">1</span>&#125;&#123;<span class="number">3</span>&#125;,m2_x=r-\frac&#123;r-l&#125;&#123;<span class="number">3</span>&#125;=\frac&#123;<span class="number">5</span>&#125;&#123;<span class="number">3</span>&#125;$,$m1$的函数值小一些，我们把$l$**下移**下去.  </span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ \ $它就会变成$[\frac&#123;<span class="number">5</span>&#125;&#123;<span class="number">3</span>&#125;,<span class="number">3</span>]$,以此类推,我们可以把$l$和$r$ 夹在一个范围之内.  </span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ \ $~~了解了这些过后,我们就会明白~~[$P3382$](https:<span class="comment">//www.luogu.com.cn/problem/P3382)&amp;[$17$](http://222.180.160.110:1024/problem/17)就是板子题了  </span></span><br><span class="line"></span><br><span class="line">$<span class="number">3.</span>EX$三分  </span><br><span class="line">&gt;题目传送门:[$OJ$](http:<span class="comment">//222.180.160.110:1024/problem/21)$\ \ \ \ $[$Luogu$](https://www.luogu.com.cn/problem/P2571)  </span></span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ $先声明一下,我到现在都还是**没有过掉**,我不知道为什么它$WA$成$<span class="number">80</span>$分,但我敢相信它的思路一定是正确的.  </span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ $我们不难发现,总的时间一定是:  </span><br><span class="line">$$Time=\frac&#123;AE&#125;&#123;V_&#123;AB&#125;&#125;+\frac&#123;EF&#125;&#123;V&#125;+\frac&#123;FD&#125;&#123;V_&#123;CD&#125;&#125;$$</span><br><span class="line">$\ \ \ \ \ \ $首先,我们可以假设**传送带速度大于走路的速度**,并且我们在$AB$段离开的点已经定下来为$E$点  </span><br><span class="line">![无标题.png](https:<span class="comment">//i.loli.net/2020/01/11/CmugQolaNOb5epT.png)   </span></span><br><span class="line">$\ \ \ \ \ \ $我们假设$A→E→N→D$为最优路径,我们来看以下三种情况(讨论中我们自动忽略$A→E$与$P→D$的时间).  </span><br><span class="line"></span><br><span class="line">$$\texttt&#123;No<span class="number">.1</span> E&#125;→\texttt&#123;M&#125;→\texttt&#123;D&#125;:T=\frac&#123;x&#125;&#123;V&#125;+\frac&#123;a+b&#125;&#123;V_&#123;CD&#125;&#125;$$  </span><br><span class="line"></span><br><span class="line">$$\texttt&#123;No<span class="number">.2</span> E&#125;→\texttt&#123;N&#125;→\texttt&#123;D&#125;:T=\frac&#123;y&#125;&#123;V&#125;+\frac&#123;b&#125;&#123;V_&#123;CD&#125;&#125;$$   </span><br><span class="line"></span><br><span class="line">$$\texttt&#123;No<span class="number">.3</span> E&#125;→\texttt&#123;P&#125;→\texttt&#123;D&#125;:T=\frac&#123;z&#125;&#123;V&#125;$$   </span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ \ $鉴于$x&lt;y&lt;z,$我们设$x=y-p,z=y+q$,所以我们的式子可以表示为:  </span><br><span class="line">$$\texttt&#123;No<span class="number">.1</span> E&#125;→\texttt&#123;M&#125;→\texttt&#123;D&#125;:T=\frac&#123;y-p&#125;&#123;V&#125;+\frac&#123;a+b&#125;&#123;V_&#123;CD&#125;&#125;$$  </span><br><span class="line"></span><br><span class="line">$$\texttt&#123;No<span class="number">.2</span> E&#125;→\texttt&#123;N&#125;→\texttt&#123;D&#125;:T=\frac&#123;y&#125;&#123;V&#125;+\frac&#123;b&#125;&#123;V_&#123;CD&#125;&#125;$$   </span><br><span class="line"></span><br><span class="line">$$\texttt&#123;No<span class="number">.3</span> E&#125;→\texttt&#123;P&#125;→\texttt&#123;D&#125;:T=\frac&#123;y+q&#125;&#123;V&#125;$$</span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ \ $将上述三个式子全都减掉相同的$\frac&#123;y&#125;&#123;V&#125;$,原式又会变为  </span><br><span class="line">$$\texttt&#123;No<span class="number">.1</span> E&#125;→\texttt&#123;M&#125;→\texttt&#123;D&#125;:T=\frac&#123;a+b&#125;&#123;V_&#123;CD&#125;&#125;-\frac&#123;p&#125;&#123;V&#125;$$  </span><br><span class="line"></span><br><span class="line">$$\texttt&#123;No<span class="number">.2</span> E&#125;→\texttt&#123;N&#125;→\texttt&#123;D&#125;:T=\frac&#123;b&#125;&#123;V_&#123;CD&#125;&#125;$$   </span><br><span class="line"></span><br><span class="line">$$\texttt&#123;No<span class="number">.3</span> E&#125;→\texttt&#123;P&#125;→\texttt&#123;D&#125;:T=\frac&#123;q&#125;&#123;V&#125;$$    </span><br><span class="line">$\ \ \ \ \ \ \ $一般情况下,$V_&#123;CD&#125;&gt;V$,所以可以得到这是一个**单峰函数**的,当然,如果$V_&#123;CD&#125;&lt;V$,那我们直接**特判**就好啦.  </span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ \ $以此类推,我们也就得到了对于$AB$段的函数单峰性证明  ~~(其实**并没有**,但我真的证不出来了)~~  </span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ \ $所以这道题的正解就是,先**三分**$AB$上的$E$点,然后用三分出来的$E$点三分$CD$上的$F$点,然后用求得的最优解逼近最正确的$E$点.  </span><br><span class="line"></span><br><span class="line">$$\mathcal&#123;CODE(<span class="number">8</span>Opts)&#125;$$</span><br><span class="line">&gt;$\ \ \ \ \ \ \ $[码量过大,为防止卡顿故使用云剪贴板](https:<span class="comment">//www.luogu.com.cn/paste/8i3r74ab)</span></span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ \ $~~当然这道题也可以用模拟退火,粒子群优化和暴力(拆成$<span class="number">500</span>$个点)乱搞~~  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">$$\texttt&#123;四、背包DP&#125;$$  </span><br><span class="line">$\ \ \ \ \ \ $[很明显,我有写过](https:<span class="comment">//www.luogu.com.cn/blog/1-2-1/bag-question)  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">$$\texttt&#123;五、树形DP&#125;$$  </span><br><span class="line">$\ \ \ \ \ \ $~~我们会树,我们会$DP$,我们会树上$DP$.~~   </span><br><span class="line"></span><br><span class="line">$<span class="number">1.</span>$树的直径  </span><br><span class="line">$\ \ \ \ \ \ $对于树的直径，我们普遍有两种做法</span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ $一种是贪心两遍 $\text&#123;dfs&#125;$或 $\text&#123;bfs&#125;$,另外一种是树形 $\text&#123;dp&#125;$   </span><br><span class="line">$\ \ \ $①.定义   </span><br><span class="line">$\ \ \ \ \ \ $给定一棵树，  </span><br><span class="line">$\ \ \ \ \ \ $树中每条边都有一个权值，  </span><br><span class="line">$\ \ \ \ \ \ $树中两点之间的距离定义为连接两点的路径边权之和。  </span><br><span class="line">$\ \ \ \ \ \ $树中最远的两个节点之间的距离被称为树的直径，  </span><br><span class="line">$\ \ \ \ \ \ $连接这两点的路径被称为树的最长链  </span><br><span class="line">$\ \ \ \ \ \ $简单来说，树的直径就是树上一条最长的链的距离  </span><br><span class="line"></span><br><span class="line">$\ \ \ $②.流程  </span><br><span class="line">$\ \ \ \ \ \ $我们以下图为例  </span><br><span class="line">![graph.png](https:<span class="comment">//i.loli.net/2020/01/11/NdLv9QktSAXlPqW.png)   </span></span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ $我们任意选择一个点$W$,这里我们以$<span class="number">2</span>$为例   </span><br><span class="line">$\ \ \ \ \ \ $那么离$<span class="number">2</span>$最远的就是$<span class="number">6</span>$,我们再找一遍离$<span class="number">6</span>$最远的节点:$<span class="number">4</span>$。   </span><br><span class="line">$\ \ \ \ \ \ $所以我们的最长链就是两次找到的两个节点所形成的链.  </span><br><span class="line">$\ \ \ \ \ \ $至于正确性证明,可以看一下大佬的[$\texttt&#123;BLOG&#125;$](https:<span class="comment">//www.luogu.com.cn/blog/Loveti/problem-tree)    </span></span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ $而树形$\texttt&#123;DP&#125;$的话,我们可以用下面这种方法.   </span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ $令$\texttt&#123;DP1[i]&#125;$表示起点为$i$的最长链,$\texttt&#123;DP2[i]&#125;$表示起点为$i$的(非严格)次长链,那么我们可以得到$ans=\max\&#123;dp1[i],dp2[i]\&#125;(<span class="number">1</span> \le i \le n)$   </span><br><span class="line">$\ \ \ \ \ \ $所以转移方程肯定是这样写的($\text&#123;u&#125;$代表当前节点,$\text&#123;v&#125;$表示$\text&#123;u&#125;$的子节点):  </span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">//当中的1全都可以换成w(边权)</span></span><br><span class="line"><span class="keyword">if</span>(dp1[u]&lt;=dp1[v]+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	dp2[u]=dp1[u];<span class="comment">//这两个顺序不能变换</span></span><br><span class="line">	dp1[u]=dp1[v]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(dp2[u]&lt;=dp1[v]+<span class="number">1</span>) dp2[u]=dp1[v]+<span class="number">1</span>;<span class="comment">//else 不能去掉</span></span><br><span class="line">```   </span><br><span class="line">$\ \ \ \ \ \ \ $这个意思应该很清楚吧,如果我们能更新最长链,那么我们先更新**次长链**为**当前最长链,最长链**为当前新得到的值.  </span><br><span class="line">$\ \ \ \ \ \ \ $如果上面这个不成立,我们再来找一下能不能更新次长链  </span><br><span class="line">$\ \ \ \ \ \ \ $所以很明显,找直径的树形$\text&#123;DP&#125;$是由子节点到根节点的.  </span><br><span class="line">$\ \ \ \ \ \ \ $例题传送门:[$<span class="number">160</span>$](http:<span class="comment">//222.180.160.110:1024/problem/160)  </span></span><br><span class="line">$\ \ \ \ \ \ \ $乍一看这道题都跟树没有关系,然而事实上,我们可以把可以**互相转化**的数看做是在这两个节点之间**连了一条边**,因此这道题就是求一个树上的最长链,即树的直径.</span><br><span class="line"></span><br><span class="line">$\ \ \ \ \ \ \ $由于这道题一定是从大数转换为小数,所以我们倒序枚举即可.  </span><br><span class="line">$$\mathcal&#123;CODE&#125;$$  </span><br><span class="line">```cpp</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;<span class="built_in">vector</span>&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">50005</span>],d1[<span class="number">50005</span>],d2[<span class="number">50005</span>];</span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=n/i;j++) sum[i*j]+=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(sum[i]&lt;i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(d1[i]+<span class="number">1</span>&gt;d1[sum[i]])</span><br><span class="line">			&#123;</span><br><span class="line">				d2[sum[i]]=d1[sum[i]];</span><br><span class="line">				d1[sum[i]]=d1[i]+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(d1[i]+<span class="number">1</span>&gt;d2[sum[i]]) d2[sum[i]]=d1[i]+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=max(ans,d1[i]+d2[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></p>
<p>$2.$树的最大独立集<br>$       $这个,怎么说呢?其实就是给定一些限制,然后在满足这些限制的前提下最多/最少能取多少个点.<br>$       $具体我们以找一道<span class="external-link"><a   href="https://www.luogu.com.cn/problem/UVA1220"  target="_blank" rel="noopener">例题</a><i class="fa fa-external-link"></i></span>把.<br>$       $<span class="external-link"><a   href="https://www.luogu.com.cn/blog/1-2-1/solution-uva1220"  target="_blank" rel="noopener">解析</a><i class="fa fa-external-link"></i></span>在这里.  </p>
<p>$3.$树的重心<br>$       $考虑一个点，以它为根的树中，最大的子树节点数最少，我们把这个点称为树的重心<br>$       $举个例子，下图中重心为 $1$ 和 $2$<br><img src="https://i.loli.net/2020/01/11/oJgbeBnIY7c5drk.png" alt="graph.png"><br>$   $①求法<br>$       $求解树的重心的时候，我们通常会采用树形 $\text{dp}$<br>$       $我们用 $s[i]$ 代表以 $i$ 为根的子树节点数<br>$       dp[i]$代表以 $i$ 为根的子树中最大的子树节点个数<br>$       $显然，$dp[u]=\max(dp[u],s[v])$<br>$       $但是我们求重心的时候，是以 $u$ 为根。<br>$       $还是举上图的例子，当我们把$2$号点当成重心时，它就变成了这样<br><img src="https://i.loli.net/2020/01/11/Wl9esZHMf1F3XoS.png" alt="graph _1_.png"><br>$       $<del>这时候 2 号节点的父亲变成了儿子</del><br>$       $所以最后统计 $dp[u]$ 的时候，还要记得统计 $n-s[u]$(即以原来父亲为根的子树的节点数)  </p>
<p>$       $还是搞一个例题吧.<br>$       $题目传送门:<span class="external-link"><a   href="http://222.180.160.110:1024/problem/10795"  target="_blank" rel="noopener">$OJ$</a><i class="fa fa-external-link"></i></span>$   $<span class="external-link"><a   href="https://www.luogu.com.cn/problem/SP9942"  target="_blank" rel="noopener">$SP9942$</a><i class="fa fa-external-link"></i></span><br>$       $<del>我想知道为什么我考场上没有看出来这是重心</del>  </p>
<p>$       $我们求出来以原来每一个点的父亲一坨子树还是儿子一坨子树的节点数多,那么我们就让多的经过这条边即可.  </p>
<script type="math/tex; mode=display">\mathcal{CODE}</script><blockquote>
<p>$       $<span class="external-link"><a   href="https://www.luogu.com.cn/paste/bfc8l6d0"  target="_blank" rel="noopener">$Here it is!$</a><i class="fa fa-external-link"></i></span>  </p>
</blockquote>
<p>$       $树形$DP$先讲三大模板吧,后面再填坑.  </p>
<blockquote>
<p>To Be Continued</p>
</blockquote>
<hr>
<script type="math/tex; mode=display">\texttt{六、区间DP}</script><p>$    1.$模板?<br>$        $区间$\text{DP}$一般有这样的套路.  </p>
<pre><code class="lang-cpp">for(int len=2;len&lt;=n;len++)
{
    for(int i=1;j=len;j&lt;=n;i++,j++)
    {
        for(int k=i;k&lt;j;k++)
        {
            dp[i][j]= (max or min) (dp[i][j],dp[i][k] (+ or *) dp[k+1][j] (+ or *) (视题目而定) )
        }
    }
}
</code></pre>
<p>$    $2.套路<br>$        $ 区间$\text{DP}一般有一个$<br>$        $ 破环为链 $  \Theta(n)$ ,代码简单,不展示了.<br>$        E.g$:<span class="external-link"><a   href="http://222.180.160.110:1024/problem/152"  target="_blank" rel="noopener">$1552$</a><i class="fa fa-external-link"></i></span>$    $<span class="external-link"><a   href="https://www.luogu.com.cn/problem/P1880"  target="_blank" rel="noopener">$P1880$</a><i class="fa fa-external-link"></i></span>  </p>
<p>$    $3.例题  </p>
<blockquote>
<p>$        $<span class="external-link"><a   href="http://222.180.160.110:1024/problem/6119"  target="_blank" rel="noopener">$OJ$</a><i class="fa fa-external-link"></i></span>$   $  <span class="external-link"><a   href="https://www.luogu.com.cn/problem/P4342"  target="_blank" rel="noopener">$Luogu$</a><i class="fa fa-external-link"></i></span>  </p>
</blockquote>
<p>$         $我们记$\text{op[i]}$表示第$\text{i}$条边的操作,设$\text{dp[i][j]}$表示在$i-j$的边序列操作后所能得到的最大值.<br>$         $我们很容易就能发现:  </p>
<script type="math/tex; mode=display">\texttt{dp[i][j]=}\max\texttt{\{(dp[i][k]+dp[k+1][j])\}}\ \ (op[k+1]=='+')</script><script type="math/tex; mode=display">\texttt{dp[i][j]=}\max\texttt{\{(dp[i][k]*dp[k+1][j])\}}\ \ (op[k+1]=='*')</script><p>$         $于是你高高兴兴地交上去,发现只有$80pts$  </p>
<p>$         $为什么呢? <del>这可是IOI诶,即使再水也不至于这样吧.</del> 我们来看一下数据范围  </p>
<blockquote>
<p>$         $顶点数字都在$[-32768,32767]$ </p>
</blockquote>
<p>$         $所以很明显,这里是因为负数$\times$负数很有可能超过当前最大值,所以我们还要维护一个最小值。  </p>
<p>$         $设:$\texttt{DP1[i][j]}$维护最小值,$\texttt{DP2[i][j]}$维护最大值<br>$         $那么我们的状态转移方程就会变成下面这个亚子.  </p>
<script type="math/tex; mode=display">\texttt{if(op[k+1]=='+')}</script><script type="math/tex; mode=display">\texttt{dp1[i][j]=} \min \texttt{\{dp1[i][k]+dp1[k+1][j]\}}</script><script type="math/tex; mode=display">\texttt{dp2[i][j]=} \max \texttt{\{dp2[i][k]+dp2[k+1][j]\}}</script><script type="math/tex; mode=display">\texttt{if(op[k+1]=='*')}</script><script type="math/tex; mode=display">\texttt{dp1[i][j]=} \min \texttt{\{dp1/2[i][k]*dp1/2[k+1][j]\}}</script><script type="math/tex; mode=display">\texttt{dp2[i][j]=} \max \texttt{\{dp2/1[i][k]*dp2/1[k+1][j]\}}</script><p>$        $乘法完整打出来有$8$行,所以我稍微简化了一下,$dp1/2[i][j]$表示它既得取$dp1$,又得取$dp2$.  </p>
<script type="math/tex; mode=display">\mathcal{CODE}</script><blockquote>
<p><span class="external-link"><a   href="https://www.luogu.com.cn/paste/32t17f02"  target="_blank" rel="noopener">Here it is!</a><i class="fa fa-external-link"></i></span></p>
</blockquote>
<hr>
</div><footer class="post-footer"><div class="post-end"><p><span>------ </span><span>End of the article, thanks for your reading</span><span> ------</span></p></div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-author-name">Author: </span><span class="post-copyright-author-value"><a href="http://Forgotten-myself.github.io">Forgotten-myself</a></span></div><div class="post-copyright-link"><span class="post-copyright-link-name">Link: </span><span class="post-copyright-link-value"><a href="http://forgotten-myself.github.io/2020/01/30/2019~2020%E5%AD%A6%E5%B9%B4%E5%BA%A6%E4%B8%8AOI%E6%80%BB%E7%BB%93/">http://forgotten-myself.github.io/2020/01/30/2019~2020%E5%AD%A6%E5%B9%B4%E5%BA%A6%E4%B8%8AOI%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-notice-name">Copyright: </span><span class="post-copyright-notice-value">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> unless stating additionally</span></div></div><div class="post-tags"><span class="post-tags-item"><i class="post-tags-item__i fa fa-tags"></i><a class="post-tags-item__a" href="http://forgotten-myself.github.io/tags/%E6%80%BB%E7%BB%93/">总结</a></span></div><nav class="paginator"><div class="paginator-post"><div class="paginator-post-next"><a href="/2020/01/30/CSP-J%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"><span>CSP-J赛后总结</span><i class="fa fa-chevron-right"></i></a></div></div></nav></footer></div></div></div><aside class="sidebar" id="sidebar"><div class="sidebar-inner"><div class="sidebar-nav"><span class="sidebar-nav-toc current">Catalog</span><span class="sidebar-nav-ov">Overview</span></div><section class="sidebar-toc"><div></div></section><!-- ov = overview --><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/avatar.png" alt="avatar"></div><p class="sidebar-ov-author__p">hello world</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state__a posts" href="/archives/"><div class="sidebar-ov-state__a--count">2</div><div class="sidebar-ov-state__a--name">Archives</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span>You have read </span><span class="sidebar-reading-info-num">0</span></div><div class="sidebar-reading-line"></div></div></div></aside><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright &copy; 2020</span><span class="fa fa-heart footer-icon"></span><span>Forgotten-myself.</span></div><div><span>Powered by <a href="http://hexo.io/" title="hexo" target="_blank" rel="noopener">hexo</a></span><span> v4.2.0.</span><span class="separator">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="stun" target="_blank" rel="noopener">stun</a></span><span> v1.7.0.</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="progress"></div></div><div class="back2top" id="back2top"><i class="back2top-icon fa fa-rocket"></i></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=1.7.0"></script><script src="/js/stun-boot.js?v=1.7.0"></script><script src="/js/scroll.js?v=1.7.0"></script><script src="/js/header.js?v=1.7.0"></script><script src="/js/sidebar.js?v=1.7.0"></script></body></html>