{"meta":{"title":"Welcome","subtitle":"","description":"","author":"Forgotten-myself","url":"http://Forgotten-myself.github.io","root":"/"},"pages":[],"posts":[{"title":"2019~2020学年度上OI总结","slug":"2019~2020学年度上OI总结","date":"2020-01-30T13:45:00.000Z","updated":"2020-01-30T13:56:13.146Z","comments":true,"path":"2020/01/30/2019~2020学年度上OI总结/","link":"","permalink":"http://forgotten-myself.github.io/2020/01/30/2019~2020%E5%AD%A6%E5%B9%B4%E5%BA%A6%E4%B8%8AOI%E6%80%BB%E7%BB%93/","excerpt":"","text":"本文同步发表于$My luogu Blog$ 从$CSP-J$后,差不多又有半年了,然后我们又要搞总结了~($≧▽≦)/~$ \\texttt{一.字符串Hash}$1.$字符串$hash$$ $简单来说,$Hash≈$把字符串转成$ULL.$$ Q:$为什么要用$ULL?$$ A:$利用$ULL$有自然溢出的特性，可以防止负数进而防止数组下标为负 $ $利用类似于进制的思想，我们就可以把一个字符串改造成$ULL$而利用这个位值的原则，我们可以轻松地求出一个字符串中任意一个子串的值. $ $设:$p_i$表示在$base$进制下第$i$位的权值(事实上这可以用$base^{i-1}$轻松求得,但空间换时间大部分情况下是划算的),$h_i$表示$s_1-s_j$的子串$hash$值 $ $所以可得:$s_l-s_r$的子串$hash$值为: \\texttt{h[r]-h[l-1]*sum[r-l+1]}其实感觉跟前缀和蛮像的 这个原理很好证明，如果想不明白的话可以用十进制举例 好像就没了? $2.$最小(大)表示法$ $尽管$LF$没讲，但个人认为这还是很好理解的.$ $以$P5990$为例,它要求一个字符串从顺时针，逆时针的顺序看过去的串是否有过，这其实相当于把这个字符串改成$12$个子串,我们求出这$12$个子串的$hash$值后取$min/max$即可表示与这个字符串等价的所有其他字符串. 以样例为例:11 2 3 4 5 6它可以被改造为:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748491 2 3 4 5 6 2 3 4 5 6 13 4 5 6 1 24 5 6 1 2 35 6 1 2 3 46 1 2 3 4 56 5 4 3 2 1 5 4 3 2 1 64 3 2 1 6 53 2 1 6 5 42 1 6 5 4 31 6 5 4 3 2&#96;&#96;&#96; 这当中最小的应该是$\\text&#123;6 5 4 3 2 1&#125;$这个子串的$hash$值，因此我们直接用$\\text&#123;6 5 4 3 2 1&#125;$的值表示这$12$个串的值记录下来即可. ------------$$\\texttt&#123;二.trie树&#125;$$ 个人认为这是学得仅次于$DP$烂的东西. $1.$概述 $\\ \\ \\ \\ \\ \\ \\ Q:$为什么要用字典树而不用字典链表什么的呢?&gt;A:元素与元素间的关系为继承的一对多关系。$\\ \\ \\ \\ \\ \\ \\ $拿字典树来说，每一个元素都可以有几个子元素，作为它之后的字母；而倘若要比对两个字符串是否相同，只需要比对在这棵字典树上，这两个串最后一个元素的祖先链(即前缀)是否相同，并且对于祖先链来说，并不用逐个比较，只需要记录访问就行 $2.$怎么建一棵字典树? $\\ \\ \\ \\ \\ \\ \\ $对于一棵字典树来说,我们用边来存储每一个字符?为什么呢?首先我们来想一想,字典树有没有根节点? $\\ \\ \\ \\ \\ \\ \\ $答案肯定是:&quot;没有&quot;,原因很简单,根节点的个数决定它树的棵树，如果根节点太多的话那这个数据结构没有方便可言.~~而且它叫字典树而不是字典森林~~ $\\ \\ \\ \\ \\ \\ \\ $那没有根节点，也就没有了用点存储字符的可能性,因此用边是唯一的选择,节点的话，我们留着拿来编号用. $$\\mathcal&#123;CODE&#125;$$ &#96;&#96;&#96;cppint trie[N][26],End[N],tot&#x3D;1;void insert(char a[])&#123; int len&#x3D;strlen(a),p&#x3D;1; for(int i&#x3D;0;i&lt;len;i++) &#123; int ch&#x3D;a[i]-&#39;a&#39;; if(trie[p][ch]&#x3D;&#x3D;0) trie[p][ch]&#x3D;(++tot); p&#x3D;trie[p][ch]; &#125; End[p]++;&#125;$3.$查询$ trie[i][ch]$表示$i$节点有$ch$这个字符,其编号为$tot$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206bool Search(char a[])&#123; int len=strlen(a),p=1,ans=0; for(int i=0;i&lt;len;i++) &#123; p=trie[p][a[i]-'a']; if (p==0) return false; &#125; return true;&#125;``` $\\ \\ \\ \\ \\ \\ \\ $这段代码表示查询前面有没有是它前缀的字符串. $\\ \\ \\ \\ \\ \\ \\ $那我们之前打的$End$标记是干吗的呢?我们把代码改成这个亚子. ```cppint Search(char a[])&#123; int len=strlen(a),p=1,ans=0; for(int i=0;i&lt;len;i++) &#123; p=trie[p][a[i]-'a']; if(p==0) return ans; ans+=End[p]; &#125; return ans;&#125;``` $\\ \\ \\ \\ \\ \\ \\ $这就能查询之前建过的所有链中,有多少单词是当前要查询的单词的**前缀** ~~(好像还是没啥用?)~~. $4.01\\ Trie$ $\\ \\ \\ \\ \\ \\ \\ 01\\ Trie$树可以干吗?~~搞异或~~,求一个数列当中任意两个数异或能得到的最大值 $\\ \\ \\ \\ \\ \\ \\ $由异或的定义可得: $$\\texttt&#123;0 xor 0=0\\ \\ \\ \\ \\ 0 xor 1=1\\ \\ \\ \\ \\ 1 xor 0=1\\ \\ \\ \\ \\ 1 xor 1=0&#125;$$ $\\ \\ \\ \\ \\ \\ \\ $再根据一个小小的贪心，**最高位如果是$1$的话,下面的低位不管是什么都比不上它的**. $\\ \\ \\ \\ \\ \\ \\ E.g:(1000)_2&gt;(0111)_2$ $\\ \\ \\ \\ \\ \\ \\ $所以剩下的就是，我们把一个数改成$32$位**二进制**数放在$Trie$树上，然后发现与当前位上**不一样**的数就**直接**往那条边走，否则就只能往当前位上和它**相同数字方向**走. $\\ \\ \\ \\ \\ \\ \\ $我能贴个[$5996$](http://222.180.160.110:1024/problem/5996)的[代码](https://www.luogu.com.cn/paste/imgihbdm)就跑吗? ------------$$\\texttt&#123;三、树状数组&#125;$$ [或许我有写过?](https://www.luogu.com.cn/blog/1-2-1/BIT-note) ------------$$\\texttt&#123;四、二分 and 三分&#125;$$$1.$二分 $\\ \\ \\ \\ \\ \\ \\ $对于一个有单调性的函数.(我们也可以把一个问题的解看做是一个单调函数)我们可以用二分求出它与$x$轴的交点(这个问题的解) $\\ \\ \\ \\ \\ \\ \\ $还是举个例子吧[$P1314$](https://www.luogu.com.cn/problem/P1314) ~~(好像这道题也可以三分?)~~ $\\ \\ \\ \\ \\ \\ \\ $对于这题，我们可以发现，选不同的$W$会有不同的差值,而$W$越大，矿石选的越少，$W$越**小**，矿石选的越**多**,自然,随着$W$**增大**,$Y$值**减小** $\\ \\ \\ \\ \\ \\ \\ $所以我们需要做的,就只要**二分**$W$,然后对于每一个求出的$W$进行一次**求解**(要用前缀和优化)找到与目标$Y$**最接近的值**即可. $\\ \\ \\ \\ \\ \\ \\ $再举个例子[$P2619$](https://www.luogu.com.cn/problem/P2619) $\\ \\ \\ \\ \\ \\ \\ $这道题我们可以清楚得看到，在保证最优解的情况下,选择白色边的数量是很难决定的.那不如……?我们**先跑一边最优解**(最小生成树),如果刚好有$need$条边,那么就可以直接输出,那如果不然呢? $\\ \\ \\ \\ \\ \\ \\ 1.$如果它白边**少**了,那么我们可以让白边的权值$down$(**减掉一个值**),最后答案再$up$(加$need$条边回去) $\\ \\ \\ \\ \\ \\ \\ 2.$如果它白边**多**了,那么我们可以让白边的权值$up$(**加上一个值**),最后答案再$down$(减$need$条边回去) $\\ \\ \\ \\ \\ \\ \\ $所以很明显,我们**二分**这个**加/减去的值**$(l-100,r=100)$,最后只要求得白边$\\le need$即可更新答案. $2.$三分 $\\ \\ \\ \\ \\ \\ \\ $三分最常见的用法就是求一个**区间单峰函数**的**极值**,最常见的单峰函数是什么?当然就是**二次函数**啦~\\(≧▽≦)/~. ![8f495fbf7a0ea76deb58e86555428b07_2_0_photo.png](https://i.loli.net/2020/01/10/vrkwlBIOKqUWhst.png) $\\ \\ \\ \\ \\ \\ \\ $对于一个二次函数，我们假设其**定义域**在$[l_i,r_i]$,我们手算的时候,假设这个区间为$[-3,3]$吧. $\\ \\ \\ \\ \\ \\ \\ $那么,我们可以求出这个区间的**三等分点**,对于这个例子来说,我们的三等分点就是$m1_x=l+\\frac&#123;r-l&#125;&#123;3&#125;=1,m2_x=r-\\frac&#123;r-l&#125;&#123;3&#125;=1$,它们的函数值相等,我们任意下移某一边的点,这里我们下移$l$，变为$[-1,3]$ $\\ \\ \\ \\ \\ \\ \\ $继续计算,$m1_x=l+\\frac&#123;r-l&#125;&#123;3&#125;=\\frac&#123;1&#125;&#123;3&#125;,m2_x=r-\\frac&#123;r-l&#125;&#123;3&#125;=\\frac&#123;5&#125;&#123;3&#125;$,$m1$的函数值小一些，我们把$l$**下移**下去. $\\ \\ \\ \\ \\ \\ \\ $它就会变成$[\\frac&#123;5&#125;&#123;3&#125;,3]$,以此类推,我们可以把$l$和$r$ 夹在一个范围之内. $\\ \\ \\ \\ \\ \\ \\ $~~了解了这些过后,我们就会明白~~[$P3382$](https://www.luogu.com.cn/problem/P3382)&amp;[$17$](http://222.180.160.110:1024/problem/17)就是板子题了 $3.EX$三分 &gt;题目传送门:[$OJ$](http://222.180.160.110:1024/problem/21)$\\ \\ \\ \\ $[$Luogu$](https://www.luogu.com.cn/problem/P2571) $\\ \\ \\ \\ \\ \\ $先声明一下,我到现在都还是**没有过掉**,我不知道为什么它$WA$成$80$分,但我敢相信它的思路一定是正确的. $\\ \\ \\ \\ \\ \\ $我们不难发现,总的时间一定是: $$Time=\\frac&#123;AE&#125;&#123;V_&#123;AB&#125;&#125;+\\frac&#123;EF&#125;&#123;V&#125;+\\frac&#123;FD&#125;&#123;V_&#123;CD&#125;&#125;$$$\\ \\ \\ \\ \\ \\ $首先,我们可以假设**传送带速度大于走路的速度**,并且我们在$AB$段离开的点已经定下来为$E$点 ![无标题.png](https://i.loli.net/2020/01/11/CmugQolaNOb5epT.png) $\\ \\ \\ \\ \\ \\ $我们假设$A→E→N→D$为最优路径,我们来看以下三种情况(讨论中我们自动忽略$A→E$与$P→D$的时间). $$\\texttt&#123;No.1 E&#125;→\\texttt&#123;M&#125;→\\texttt&#123;D&#125;:T=\\frac&#123;x&#125;&#123;V&#125;+\\frac&#123;a+b&#125;&#123;V_&#123;CD&#125;&#125;$$ $$\\texttt&#123;No.2 E&#125;→\\texttt&#123;N&#125;→\\texttt&#123;D&#125;:T=\\frac&#123;y&#125;&#123;V&#125;+\\frac&#123;b&#125;&#123;V_&#123;CD&#125;&#125;$$ $$\\texttt&#123;No.3 E&#125;→\\texttt&#123;P&#125;→\\texttt&#123;D&#125;:T=\\frac&#123;z&#125;&#123;V&#125;$$ $\\ \\ \\ \\ \\ \\ \\ $鉴于$x&lt;y&lt;z,$我们设$x=y-p,z=y+q$,所以我们的式子可以表示为: $$\\texttt&#123;No.1 E&#125;→\\texttt&#123;M&#125;→\\texttt&#123;D&#125;:T=\\frac&#123;y-p&#125;&#123;V&#125;+\\frac&#123;a+b&#125;&#123;V_&#123;CD&#125;&#125;$$ $$\\texttt&#123;No.2 E&#125;→\\texttt&#123;N&#125;→\\texttt&#123;D&#125;:T=\\frac&#123;y&#125;&#123;V&#125;+\\frac&#123;b&#125;&#123;V_&#123;CD&#125;&#125;$$ $$\\texttt&#123;No.3 E&#125;→\\texttt&#123;P&#125;→\\texttt&#123;D&#125;:T=\\frac&#123;y+q&#125;&#123;V&#125;$$$\\ \\ \\ \\ \\ \\ \\ $将上述三个式子全都减掉相同的$\\frac&#123;y&#125;&#123;V&#125;$,原式又会变为 $$\\texttt&#123;No.1 E&#125;→\\texttt&#123;M&#125;→\\texttt&#123;D&#125;:T=\\frac&#123;a+b&#125;&#123;V_&#123;CD&#125;&#125;-\\frac&#123;p&#125;&#123;V&#125;$$ $$\\texttt&#123;No.2 E&#125;→\\texttt&#123;N&#125;→\\texttt&#123;D&#125;:T=\\frac&#123;b&#125;&#123;V_&#123;CD&#125;&#125;$$ $$\\texttt&#123;No.3 E&#125;→\\texttt&#123;P&#125;→\\texttt&#123;D&#125;:T=\\frac&#123;q&#125;&#123;V&#125;$$ $\\ \\ \\ \\ \\ \\ \\ $一般情况下,$V_&#123;CD&#125;&gt;V$,所以可以得到这是一个**单峰函数**的,当然,如果$V_&#123;CD&#125;&lt;V$,那我们直接**特判**就好啦. $\\ \\ \\ \\ \\ \\ \\ $以此类推,我们也就得到了对于$AB$段的函数单峰性证明 ~~(其实**并没有**,但我真的证不出来了)~~ $\\ \\ \\ \\ \\ \\ \\ $所以这道题的正解就是,先**三分**$AB$上的$E$点,然后用三分出来的$E$点三分$CD$上的$F$点,然后用求得的最优解逼近最正确的$E$点. $$\\mathcal&#123;CODE(8Opts)&#125;$$&gt;$\\ \\ \\ \\ \\ \\ \\ $[码量过大,为防止卡顿故使用云剪贴板](https://www.luogu.com.cn/paste/8i3r74ab)$\\ \\ \\ \\ \\ \\ \\ $~~当然这道题也可以用模拟退火,粒子群优化和暴力(拆成$500$个点)乱搞~~ ------------$$\\texttt&#123;四、背包DP&#125;$$ $\\ \\ \\ \\ \\ \\ $[很明显,我有写过](https://www.luogu.com.cn/blog/1-2-1/bag-question) ------------$$\\texttt&#123;五、树形DP&#125;$$ $\\ \\ \\ \\ \\ \\ $~~我们会树,我们会$DP$,我们会树上$DP$.~~ $1.$树的直径 $\\ \\ \\ \\ \\ \\ $对于树的直径，我们普遍有两种做法$\\ \\ \\ \\ \\ \\ $一种是贪心两遍 $\\text&#123;dfs&#125;$或 $\\text&#123;bfs&#125;$,另外一种是树形 $\\text&#123;dp&#125;$ $\\ \\ \\ $①.定义 $\\ \\ \\ \\ \\ \\ $给定一棵树， $\\ \\ \\ \\ \\ \\ $树中每条边都有一个权值， $\\ \\ \\ \\ \\ \\ $树中两点之间的距离定义为连接两点的路径边权之和。 $\\ \\ \\ \\ \\ \\ $树中最远的两个节点之间的距离被称为树的直径， $\\ \\ \\ \\ \\ \\ $连接这两点的路径被称为树的最长链 $\\ \\ \\ \\ \\ \\ $简单来说，树的直径就是树上一条最长的链的距离 $\\ \\ \\ $②.流程 $\\ \\ \\ \\ \\ \\ $我们以下图为例 ![graph.png](https://i.loli.net/2020/01/11/NdLv9QktSAXlPqW.png) $\\ \\ \\ \\ \\ \\ $我们任意选择一个点$W$,这里我们以$2$为例 $\\ \\ \\ \\ \\ \\ $那么离$2$最远的就是$6$,我们再找一遍离$6$最远的节点:$4$。 $\\ \\ \\ \\ \\ \\ $所以我们的最长链就是两次找到的两个节点所形成的链. $\\ \\ \\ \\ \\ \\ $至于正确性证明,可以看一下大佬的[$\\texttt&#123;BLOG&#125;$](https://www.luogu.com.cn/blog/Loveti/problem-tree) $\\ \\ \\ \\ \\ \\ $而树形$\\texttt&#123;DP&#125;$的话,我们可以用下面这种方法. $\\ \\ \\ \\ \\ \\ $令$\\texttt&#123;DP1[i]&#125;$表示起点为$i$的最长链,$\\texttt&#123;DP2[i]&#125;$表示起点为$i$的(非严格)次长链,那么我们可以得到$ans=\\max\\&#123;dp1[i],dp2[i]\\&#125;(1 \\le i \\le n)$ $\\ \\ \\ \\ \\ \\ $所以转移方程肯定是这样写的($\\text&#123;u&#125;$代表当前节点,$\\text&#123;v&#125;$表示$\\text&#123;u&#125;$的子节点): ```cpp//当中的1全都可以换成w(边权)if(dp1[u]&lt;=dp1[v]+1)&#123; dp2[u]=dp1[u];//这两个顺序不能变换 dp1[u]=dp1[v]+1;&#125;else if(dp2[u]&lt;=dp1[v]+1) dp2[u]=dp1[v]+1;//else 不能去掉``` $\\ \\ \\ \\ \\ \\ \\ $这个意思应该很清楚吧,如果我们能更新最长链,那么我们先更新**次长链**为**当前最长链,最长链**为当前新得到的值. $\\ \\ \\ \\ \\ \\ \\ $如果上面这个不成立,我们再来找一下能不能更新次长链 $\\ \\ \\ \\ \\ \\ \\ $所以很明显,找直径的树形$\\text&#123;DP&#125;$是由子节点到根节点的. $\\ \\ \\ \\ \\ \\ \\ $例题传送门:[$160$](http://222.180.160.110:1024/problem/160) $\\ \\ \\ \\ \\ \\ \\ $乍一看这道题都跟树没有关系,然而事实上,我们可以把可以**互相转化**的数看做是在这两个节点之间**连了一条边**,因此这道题就是求一个树上的最长链,即树的直径.$\\ \\ \\ \\ \\ \\ \\ $由于这道题一定是从大数转换为小数,所以我们倒序枚举即可. $$\\mathcal&#123;CODE&#125;$$ ```cpp#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int sum[50005],d1[50005],d2[50005];int main() &#123; int n; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) &#123; for(int j=2;j&lt;=n/i;j++) sum[i*j]+=i; &#125; for(int i=n;i&gt;=1;i--) &#123; if(sum[i]&lt;i) &#123; if(d1[i]+1&gt;d1[sum[i]]) &#123; d2[sum[i]]=d1[sum[i]]; d1[sum[i]]=d1[i]+1; &#125; else if(d1[i]+1&gt;d2[sum[i]]) d2[sum[i]]=d1[i]+1; &#125; &#125; int ans=-1; for(int i=1;i&lt;=n;i++) ans=max(ans,d1[i]+d2[i]); printf(\"%d\",ans); return 0;&#125; $2.$树的最大独立集$ $这个,怎么说呢?其实就是给定一些限制,然后在满足这些限制的前提下最多/最少能取多少个点.$ $具体我们以找一道例题把.$ $解析在这里. $3.$树的重心$ $考虑一个点，以它为根的树中，最大的子树节点数最少，我们把这个点称为树的重心$ $举个例子，下图中重心为 $1$ 和 $2$$ $①求法$ $求解树的重心的时候，我们通常会采用树形 $\\text{dp}$$ $我们用 $s[i]$ 代表以 $i$ 为根的子树节点数$ dp[i]$代表以 $i$ 为根的子树中最大的子树节点个数$ $显然，$dp[u]=\\max(dp[u],s[v])$$ $但是我们求重心的时候，是以 $u$ 为根。$ $还是举上图的例子，当我们把$2$号点当成重心时，它就变成了这样$ $这时候 2 号节点的父亲变成了儿子$ $所以最后统计 $dp[u]$ 的时候，还要记得统计 $n-s[u]$(即以原来父亲为根的子树的节点数) $ $还是搞一个例题吧.$ $题目传送门:$OJ$$ $$SP9942$$ $我想知道为什么我考场上没有看出来这是重心 $ $我们求出来以原来每一个点的父亲一坨子树还是儿子一坨子树的节点数多,那么我们就让多的经过这条边即可. \\mathcal{CODE} $ $$Here it is!$ $ $树形$DP$先讲三大模板吧,后面再填坑. To Be Continued \\texttt{六、区间DP}$ 1.$模板?$ $区间$\\text{DP}$一般有这样的套路. for(int len=2;len&lt;=n;len++) { for(int i=1;j=len;j&lt;=n;i++,j++) { for(int k=i;k&lt;j;k++) { dp[i][j]= (max or min) (dp[i][j],dp[i][k] (+ or *) dp[k+1][j] (+ or *) (视题目而定) ) } } } $ $2.套路$ $ 区间$\\text{DP}一般有一个$$ $ 破环为链 $ \\Theta(n)$ ,代码简单,不展示了.$ E.g$:$1552$$ $$P1880$ $ $3.例题 $ $$OJ$$ $ $Luogu$ $ $我们记$\\text{op[i]}$表示第$\\text{i}$条边的操作,设$\\text{dp[i][j]}$表示在$i-j$的边序列操作后所能得到的最大值.$ $我们很容易就能发现: \\texttt{dp[i][j]=}\\max\\texttt{\\{(dp[i][k]+dp[k+1][j])\\}}\\ \\ (op[k+1]=='+')\\texttt{dp[i][j]=}\\max\\texttt{\\{(dp[i][k]*dp[k+1][j])\\}}\\ \\ (op[k+1]=='*')$ $于是你高高兴兴地交上去,发现只有$80pts$ $ $为什么呢? 这可是IOI诶,即使再水也不至于这样吧. 我们来看一下数据范围 $ $顶点数字都在$[-32768,32767]$ $ $所以很明显,这里是因为负数$\\times$负数很有可能超过当前最大值,所以我们还要维护一个最小值。 $ $设:$\\texttt{DP1[i][j]}$维护最小值,$\\texttt{DP2[i][j]}$维护最大值$ $那么我们的状态转移方程就会变成下面这个亚子. \\texttt{if(op[k+1]=='+')}\\texttt{dp1[i][j]=} \\min \\texttt{\\{dp1[i][k]+dp1[k+1][j]\\}}\\texttt{dp2[i][j]=} \\max \\texttt{\\{dp2[i][k]+dp2[k+1][j]\\}}\\texttt{if(op[k+1]=='*')}\\texttt{dp1[i][j]=} \\min \\texttt{\\{dp1/2[i][k]*dp1/2[k+1][j]\\}}\\texttt{dp2[i][j]=} \\max \\texttt{\\{dp2/1[i][k]*dp2/1[k+1][j]\\}}$ $乘法完整打出来有$8$行,所以我稍微简化了一下,$dp1/2[i][j]$表示它既得取$dp1$,又得取$dp2$. \\mathcal{CODE} Here it is!","categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"http://forgotten-myself.github.io/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"CSP-J赛后总结","slug":"CSP-J赛后总结","date":"2020-01-30T13:44:00.000Z","updated":"2020-01-30T14:02:54.541Z","comments":true,"path":"2020/01/30/CSP-J赛后总结/","link":"","permalink":"http://forgotten-myself.github.io/2020/01/30/CSP-J%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/","excerpt":"","text":"花$30$分钟切了$T1$和$T2$$T1$:吸取前车之鉴，没有用$getchar()$,之前有用$getchar$然后$100pts-&gt;2pts$的经历（感谢@C20211711刘君实1亲身测试能用$getchar$） $T2$：读题时、没注意 1票价不超过地铁票价的公交车 于是花了$5$分钟调+手算然后又看了一遍样例解释才注意到。于是这句话使我的$queue$变成了$vector$重做了一遍，并且还花了$2$分钟想到$erase$与$j—$(差点没打$j—$的我和的确没打$j—$的@C2022汪冠宇)结合加速(不加会$T$掉$50$分)。 $T3:$按照经验，$T4$比$T3$简单，所以我先瞟了两眼，第一眼:完全背包，第二眼:贪心，就这么与正解擦肩而过，先打了$10\\%T=1$的情况进$T4$ $T4:$看到这道题我分析出$Yes$=有一条从$a$到$1$的长$L$的路径，反之$No$即为没有。。。然后就不知道怎么做了，于是打了一个$dfs$骗分，嫌不够再（没事找事）加了个记忆化。然后:数组$[10000][100]$,并且我忘了$bool$的$false$转$int$为$0$所以一开始写成这个亚子:12345678910111213int mem[10000][100]bool dfs(int a,int l)&#123; if(mem[a][l]) return mem[a][l]; if(l==0) &#123; if(a==1) return true; else return false; &#125; bool re=false; for(int i=0;i&lt;G[a].size();i++) re|=dfs(G[a][i],l-1); return mem[a][l]=re;&#125;第三行在$mem[a][l]=false$时是根本没用的，该$T$还是会$T$(跟朴素的dfs一个分，测出来还很五颜六色)然后我们改成这个亚子:1234567891011121314mem[100000][1000]bool dfs(int a,int l)&#123; if(mem[a][l]) return mem[a][l]==-1?0:1; if(l==0) &#123; if(a==1) return true; else return false; &#125; bool re=false; for(int i=0;i&lt;G[a].size();i++) re|=dfs(G[a][i],l-1); mem[a][l]=(re==0?-1:1); return re;&#125;它就有了$75pts$死了，还是不该偷懒不算数组大小然后开小了。然后再动动脑子把$mem=0$的情况改一改，多了$40pts$ $T3:$骗分，预计得分$25-40$,实际得分:$15$···先打了两次贪心，自己出的数据都挂掉了，看时间不多开始骗分.骗的时候都没想到$T=2$的简单情况直接性价比贪心，无脑枚举··· 总的来说，我们得到了如下宝贵经验:$1.getchar()$除了快读和吞回车基本不要打(尽量吞回车都不要用)$2.$仔细读题，勾画重点$3.$各种想到的算法都试一试$4.$骗分也要骗得有技术含量，不要犯低级错误$5.$数组一定要算大小 事后:发现$T4$的$Yes$和$No$打错了···自闭了$2=AFO$","categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"http://forgotten-myself.github.io/tags/%E6%80%BB%E7%BB%93/"}]}]}